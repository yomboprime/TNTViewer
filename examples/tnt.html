<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TNT Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>

	<body>

		<script src="js/libs/ammo.wasm.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/lil-gui.module.min.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';

			import { LDrawLoader } from './jsm/loaders/LDrawLoader.js';

			const constructionSets = [
				'LEGO',
				'TENTE',
				'EXINCASTILLOS'
			];
			let currentConstructionSet;

			let container, progressBarDiv;

			let camera, scene, renderer, controls, gui, guiData;

			let lDrawLoader;

			let parts;
			let models;
			let modelDiameter, turn;
			const meanPos = new THREE.Vector3();
			let stepsParts;
			const ANIM_STOPPED = 0;
			const ANIM_FALLING = 1;
			const ANIM_CONSTRUCTING = 2;
			const ANIM_WAIT = 3;
			let animationState;
			let animationCreated;
			let timeCurrentState;
			let timeNextState;
			let currentConstructionStep;
			let curve;

			// Physics variables
			let collisionConfiguration;
			let dispatcher;
			let broadphase;
			let solver;
			let physicsWorld;
			let dynamicObjects = [];
			let btVectorAux1;
			let btQuatAux1;
			let btTransformAux1;
			let time = 0;
			const clock = new THREE.Clock();

			const vector3Temp1 = new THREE.Vector3();
			const vector3Temp2 = new THREE.Vector3();
			const quatTemp1 = new THREE.Quaternion();
			const matrix4Temp1 = new THREE.Matrix4();
			const eulerTemp1 = new THREE.Euler();

			const ldrawPath = 'models/ldraw/';
			let dataBase;

			/*= {
				'Car': 'car.ldr_Packed.mpd',
				'Lunar Vehicle': '1621-1-LunarMPVVehicle.mpd_Packed.mpd',
				'Radar Truck': '889-1-RadarTruck.mpd_Packed.mpd',
				'Trailer': '4838-1-MiniVehicles.mpd_Packed.mpd',
				'Bulldozer': '4915-1-MiniConstruction.mpd_Packed.mpd',
				'Helicopter': '4918-1-MiniFlyers.mpd_Packed.mpd',
				'Plane': '5935-1-IslandHopper.mpd_Packed.mpd',
				'Lighthouse': '30023-1-Lighthouse.ldr_Packed.mpd',
				'X-Wing mini': '30051-1-X-wingFighter-Mini.mpd_Packed.mpd',
				'AT-ST mini': '30054-1-AT-ST-Mini.mpd_Packed.mpd',
				'AT-AT mini': '4489-1-AT-AT-Mini.mpd_Packed.mpd',
				'Shuttle': '4494-1-Imperial Shuttle-Mini.mpd_Packed.mpd',
				'TIE Interceptor': '6965-1-TIEIntercep_4h4MXk5.mpd_Packed.mpd',
				'Star fighter': '6966-1-JediStarfighter-Mini.mpd_Packed.mpd',
//				'X-Wing': '7140-1-X-wingFighter.mpd_Packed.mpd',
				'AT-ST': '10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'
			};*/

			Ammo().then( function ( AmmoLib ) {

				Ammo = AmmoLib;

				init();

			} );

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 150, 200, 250 );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				// scene

				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xdeebed );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment() ).texture;

				//scene.add( new THREE.AxesHelper( 100 ) );

				controls = new OrbitControls( camera, renderer.domElement );

				const curvePositions = [
					new THREE.Vector3( 0, 0, 0 ),
					new THREE.Vector3( 0.25, 0.38, 0 ),
					new THREE.Vector3( 0.75, 0.62, 0 ),
					new THREE.Vector3( 1, 1, 0 ),
				];
				curve = new THREE.CatmullRomCurve3( curvePositions );

				//

				lDrawLoader = new LDrawLoader();
				lDrawLoader.smoothNormals = true;

				currentConstructionSet = 'TENTE';

				getModelsDataBase( currentConstructionSet, ( db ) => {

					dataBase = db;

					const urlParams = new URLSearchParams( window.location.search );
					let initialModel = urlParams.get( 'modelPath' );
					if ( ! initialModel ) {

						initialModel = 'oficiales/Aire_0501_servicio_autopista.ldr';
						//initialModel = 'customs/roverlunar.ldr';

					}

					guiData = {
						modelFileName: initialModel,
						startAnimation: startAnimation,
						oneStep: false,
						displayLines: true
					};

					window.addEventListener( 'resize', onWindowResize );

					progressBarDiv = document.createElement( 'div' );
					progressBarDiv.innerText = 'Loading...';
					progressBarDiv.style.fontSize = '3em';
					progressBarDiv.style.color = '#888';
					progressBarDiv.style.display = 'block';
					progressBarDiv.style.position = 'absolute';
					progressBarDiv.style.top = '50%';
					progressBarDiv.style.width = '100%';
					progressBarDiv.style.textAlign = 'center';

					initPhysics();

					reloadObject( true );

					animate();

				} );

			}

			function initPhysics() {

				// Physics configuration

				collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
				broadphase = new Ammo.btDbvtBroadphase();
				solver = new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
				physicsWorld.setGravity( new Ammo.btVector3( 0, - 150, 0 ) );

				// Create the floor body

				const groundShape = new Ammo.btStaticPlaneShape( new Ammo.btVector3( 0, 1, 0 ), 0 );
				const groundTransform = new Ammo.btTransform();
				groundTransform.setIdentity();
				const groundMass = 0;
				const groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
				const groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
				const groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
				physicsWorld.addRigidBody( groundBody );

				btVectorAux1 = new Ammo.btVector3( 0, 0, 0 );
				btQuatAux1 = new Ammo.btQuaternion( 0, 0, 0, 1 );
				btTransformAux1 = new Ammo.btTransform();

			}

			function updatePhysics( deltaTime ) {

				physicsWorld.stepSimulation( deltaTime, 5 );

				// Update objects
				for ( let i in dynamicObjects ) {

					const object = dynamicObjects[ i ];
					const objPhys = object.userData.physicsBody;
					const ms = objPhys.getMotionState();
					if ( ms ) {

						ms.getWorldTransform( btTransformAux1 );
						const p = btTransformAux1.getOrigin();
						const q = btTransformAux1.getRotation();
						object.position.set( p.x(), p.y(), p.z() );
						object.quaternion.set( q.x(), q.y(), q.z(), q.w() );

					}

				}

			}

			function createRigidBody( object, physicsShape, mass ) {

				const pos = object.position;
				const quat = object.quaternion;

				const transform = btTransformAux1;
				transform.setIdentity();
				btVectorAux1.setValue( pos.x, pos.y, pos.z );
				transform.setOrigin( btVectorAux1 );
				btQuatAux1.setValue( quat.x, quat.y, quat.z, quat.w )
				transform.setRotation( btQuatAux1 );

				const motionState = new Ammo.btDefaultMotionState( transform );

				const localInertia = new Ammo.btVector3( 0, 0, 0 );
				physicsShape.calculateLocalInertia( mass, localInertia );

				const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
				const body = new Ammo.btRigidBody( rbInfo );

				body.setFriction( 0.5 );

				object.userData.physicsBody = body;

				if ( mass > 0 ) {

					dynamicObjects.push( object );

					// Disable deactivation
					body.setActivationState( 4 );

				}

				physicsWorld.addRigidBody( body );

			}

			function updateRigidBodyFromObject( object ) {

				const pos = object.position;
				const quat = object.quaternion;

				const transform = btTransformAux1;
				transform.setIdentity();
				btVectorAux1.setValue( pos.x, pos.y, pos.z );
				transform.setOrigin( btVectorAux1 );
				btQuatAux1.setValue( quat.x, quat.y, quat.z, quat.w )
				transform.setRotation( btQuatAux1 );

				const motionState = new Ammo.btDefaultMotionState( transform );

				object.userData.physicsBody.setMotionState( motionState );

			}

			function getTurnOffset() {

				//return 0;
				return 2.1 * ( turn ? modelDiameter : - modelDiameter );

			}

			function placePartRandomly( part, diameter ) {

				// TODO old.

				part.position.set(
					( Math.random() - 0.5 ) * diameter + getTurnOffset(),
					( Math.random() + 0.6 ) * diameter,
					( Math.random() - 0.5 ) * diameter
				);
				part.quaternion.setFromEuler(
					eulerTemp1.set(
						( 2 * Math.PI * Math.random() ),
						( 2 * Math.PI * Math.random() ),
						( 2 * Math.PI * Math.random() )
					)
				);

			}

			function updateObjectsVisibility() {

				function updateObjects( objects ) {
					for ( let i in objects ) {

						objects[ i ].traverse( c => {

							if ( c.isLineSegments ) {

								c.visible = guiData.displayLines;

							}

						} );

					}

				}

				updateObjects( models );
				updateObjects( parts );

			}

			function isPartType( type ) {

				return type === 'Part' || type === 'Unofficial_Part';

			}

			function reloadObject( resetCamera ) {

				if ( parts ) for ( let i in parts ) {

					scene.remove( parts[ i ] );
					physicsWorld.removeRigidBody( parts[ i ].userData.physicsBody );

				}
				parts = undefined;
				if ( models ) for ( let i in models ) scene.remove( models[ i ] );
				models = undefined;

				updateProgressBar( 0 );
				showProgressBar();

				lDrawLoader.setPath( getLibraryPath( currentConstructionSet ) );
				lDrawLoader.preloadMaterials( 'LDConfig.ldr' ).then( () => {

					lDrawLoader.setPartsLibraryPath( getLibraryPath( currentConstructionSet ) );
					lDrawLoader.setPath( getModelPath( currentConstructionSet ) );
					lDrawLoader.load( guiData.modelFileName, function ( model ) {

						if ( parts ) {

							for ( let i in parts ) {

								const part = parts[ i ];

								scene.remove( part );

								physicsWorld.removeRigidBody( part.userData.physicsBody );

							}

						}
						if ( models ) for ( let i in models ) scene.remove( models[ i ] );

						parts = [];
						models = [];
						stepsParts = [];
						dynamicObjects = [];
						turn = true;

						// Convert from LDraw coordinates: rotate 180 degrees around OX
						model.rotation.x = Math.PI;

						const modelBbox = new THREE.Box3().setFromObject( model );
						const size = modelBbox.getSize( new THREE.Vector3() );
						const radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.5;
						modelDiameter = 2 * radius;

						// Put above floor
						model.position.y = - modelBbox.min.y;

						models.push( model );
						scene.add( model );

						updateObjectsVisibility();

						time = 0;
						animationState = ANIM_STOPPED;
						animationCreated = false;

						// Adjust camera

						if ( resetCamera ) {

							const pos = modelBbox.getCenter( new THREE.Vector3() );
							pos.y += model.position.y;
							setCamera( pos.x, pos.y, pos.z );

						}

						createGUI();

						hideProgressBar();

					}, onProgress, onError );

				} );

			}

			function setCamera( x, y, z ) {

				controls.target0.set( x, y, z );
				controls.position0.set( - 2.3, 1, 2 ).multiplyScalar( modelDiameter * 0.5 ).add( controls.target0 );
				controls.reset();

			}

			function startAnimation() {

				if ( animationState !== ANIM_STOPPED ) return;

				if ( ! animationCreated ) createAnimation();
				else explode();

				// Init animation
				time = 0;
				animationState = ANIM_FALLING;
				timeCurrentState = time;
				timeNextState = time + 5;

			}

			function createAnimation() {

				animationCreated = true;

				if ( ! models || models.length === 0 ) return;

				const model = models[ 0 ];
				models.splice( 0, 1 );
				scene.remove( model );

				parts = model.children.slice();
/*
				model.traverse( c => {

					if ( isPartType( c.userData.type ) ) {

						parts.push( c );

					}

				} );
*/
				model.updateMatrixWorld( true );

				meanPos.set( 0, 0, 0 );

				for ( let i in parts ) {

					const partOrig = parts[ i ];
					const part = partOrig.clone();
					parts[ i ] = part;
					part.userData.type = partOrig.userData.type;
					part.userData.numConstructionSteps = partOrig.userData.numConstructionSteps;
					part.userData.constructionStep = partOrig.userData.constructionStep;

					matrix4Temp1.copy( part.matrixWorld );
					part.removeFromParent();

					part.position.set( 0, 0, 0 );
					part.quaternion.set( 0, 0, 0, 1 );
					part.updateMatrixWorld( true );
					const bbox = new THREE.Box3().setFromObject( part );
					bbox.getSize( vector3Temp1 );
					const sx = vector3Temp1.x;
					const sy = vector3Temp1.y;
					const sz = vector3Temp1.z;
					const objectSize = sx > sy ? ( sz > sx ? sz : sx ) : ( sz > sy ? sz : sy );
					part.userData.objectSize = objectSize;
					part.userData.sx = sx;
					part.userData.sy = sy;
					part.userData.sz = sz;

					matrix4Temp1.decompose( part.position, part.quaternion, part.scale );
					part.userData.partPosition = new THREE.Vector3().copy( part.position );
					part.userData.partQuaternion = new THREE.Quaternion().copy( part.quaternion );
					part.userData.positionStart = new THREE.Vector3();
					part.userData.positionEnd = new THREE.Vector3();
					part.userData.quaternionStart = new THREE.Quaternion();

					meanPos.add( part.userData.partPosition );

					//placePartRandomly( part, objectSize * 5 );

				}

				const numConstructionSteps = model.userData.numConstructionSteps;
				stepsParts = [];
				for ( let p in parts ) {

					const part = parts[ p ];

					let constructionStep = 0;
					if ( ! guiData.oneStep ) {

						if ( numConstructionSteps > 1 ) constructionStep = part.userData.constructionStep;
						else constructionStep = p;

					}

					if ( ! stepsParts[ constructionStep ] ) stepsParts[ constructionStep ] = [];
					stepsParts[ constructionStep ].push( part );

				}

				if ( parts.length > 0 ) {

					meanPos.multiplyScalar( 1 / parts.length );
					//setCamera( meanPos.x - getTurnOffset(), meanPos.y, meanPos.z );

				}

				meanPos.x += getTurnOffset();

				for ( let p in parts ) {

					const part = parts[ p ];

					part.position.add( meanPos );
					part.position.y += part.userData.sy * 2;

					const physicsShape = new Ammo.btBoxShape(
						new Ammo.btVector3(
							part.userData.sx * 0.5,
							part.userData.sy * 0.5,
							part.userData.sz * 0.5
						)
					);

					physicsShape.setMargin( part.userData.objectSize * 0.01 );
					const mass = Math.pow( 10 * part.userData.objectSize, 2.2 );
					createRigidBody( part, physicsShape, mass );

					scene.add( part );

				}

			}

			function handleAnimation() {

				if ( ! parts ) return;

				//const constructionDuration = 20 * Math.min( 1.3, Math.max( 0.5, stepsParts.length / 60 ) );
				//const stepDuration = constructionDuration / stepsParts.length;
				const stepDuration = 1.2;
				const constructionDuration = stepDuration * stepsParts.length;

				switch ( animationState ) {

					case ANIM_FALLING:
						if ( time >= timeNextState ) beginConstruction();
						break;

					case ANIM_CONSTRUCTING:
						animPieces();
						break;

					case ANIM_WAIT:
						if ( time >= timeNextState ) explode();
						break;

				}

				function beginConstruction() {

					animationState = ANIM_CONSTRUCTING;
					timeCurrentState = time;
					currentConstructionStep = - 1;

					animPieces();

				}

				function animPieces() {

					if ( time >= timeNextState ) {

						if ( currentConstructionStep >= 0 ) {

							const stepParts = stepsParts[ currentConstructionStep ];
							for ( let i in stepParts ) {

								const part = stepParts[ i ];
								part.position.copy( part.userData.positionEnd );
								part.quaternion.copy( part.userData.partQuaternion );

							}

						}

						currentConstructionStep ++;
						if ( currentConstructionStep >= stepsParts.length ) {

							//animationState = ANIM_WAIT;
							animationState = ANIM_STOPPED;
							timeCurrentState = timeNextState;
							timeNextState = time + 3;
							//turn = ! turn;
							return;

						}

						const stepParts = stepsParts[ currentConstructionStep ];
						for ( let i in stepParts ) {

							const part = stepParts[ i ];
							part.userData.positionStart.copy( part.position );
							part.userData.quaternionStart.copy( part.quaternion );
							part.userData.positionEnd.copy( part.userData.partPosition );

							physicsWorld.removeRigidBody( part.userData.physicsBody );
							dynamicObjects.splice( dynamicObjects.indexOf( part ), 1 );

						}

						timeCurrentState = timeNextState;
						timeNextState = time + stepDuration;

					}

					const tOrig = Math.min( 1, Math.max( 0, ( time - timeCurrentState ) / stepDuration ) );

					/*
					const power = 2;
					const tPow = Math.sign( tOrig - 0.5 ) * ( 0.5 * Math.pow( 2 * Math.abs( tOrig - 0.5 ), power ) ) + 0.5;
					*/

					curve.getPoint( tOrig, vector3Temp1 );
					const tCurve = vector3Temp1.y;

					//const t = tOrig;
					//const t = tPow;
					const t = tCurve;

					const stepParts = stepsParts[ currentConstructionStep ];
					for ( let i in stepParts ) {

						const part = stepParts[ i ];

						vector3Temp1.lerpVectors( part.userData.positionStart, part.userData.positionEnd, t );
						vector3Temp2.subVectors( part.userData.positionEnd, part.userData.positionStart );
						const d = vector3Temp2.length();
						const y = d * ( - Math.pow( t - 0.5, 2 ) + 0.25 );

						part.position.copy( vector3Temp1 );
						part.position.y += y;

						part.quaternion.slerpQuaternions( part.userData.quaternionStart, part.userData.partQuaternion, t );

					}

				}

			}

			function explode() {

				for ( let i in parts ) {

					const part = parts[ i ];

					part.position.x += getTurnOffset();

					updateRigidBodyFromObject( part );
					physicsWorld.addRigidBody( part.userData.physicsBody );
					dynamicObjects.push( part );

				}

				timeCurrentState = timeNextState;
				timeNextState = time + 5;
				animationState = ANIM_FALLING;

			}


			function getModelsDataBase( constructionSet, onLoaded ) {

				const loader = new THREE.FileLoader();
				loader.load( getModelPath( constructionSet ) + 'models.json', ( content ) => {

					const dataBase = JSON.parse( content );

					onLoaded( dataBase );

				} );

			}

			function getLibraryPath( constructionSet ) {

				return ldrawPath + constructionSet  + '/';

			}

			function getModelPath( constructionSet ) {

				return ldrawPath + constructionSet  + '/models/';

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createGUI() {

				if ( gui ) {

					gui.destroy();

				}

				gui = new GUI( { width: 500 } );

				const fileNameMap = {};
				for ( let i in dataBase.pathsList ) {

					const filePath = dataBase.pathsList[ i ];
					const model = dataBase.models[ filePath ];
					fileNameMap[ model.title ] = filePath;

				}
				gui.add( guiData, 'modelFileName', fileNameMap ).name( 'Model' ).onFinishChange( function () {

					reloadObject( true );

				} );

				gui.add( guiData, 'startAnimation' ).name( 'Start animation' );

				gui.add( guiData, 'oneStep' ).name( 'Only one step' ).onFinishChange( function () {

					reloadObject( true );

				} );

				gui.add( guiData, 'displayLines' ).name( 'Display Lines' ).onChange( updateObjectsVisibility );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				const deltaTime = clock.getDelta();

				handleAnimation();

				updatePhysics( deltaTime );

				renderer.render( scene, camera );

				time += deltaTime;

			}

			function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					updateProgressBar( xhr.loaded / xhr.total );

					console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );

				}

			}

			function onError( e ) {

				const message = 'Error loading model: ' + e;
				progressBarDiv.innerText = message;
				console.log( message );

			}

			function showProgressBar() {

				document.body.appendChild( progressBarDiv );

			}

			function hideProgressBar() {

				if ( document.body.contains( progressBarDiv ) ) document.body.removeChild( progressBarDiv );

			}

			function updateProgressBar( fraction ) {

				progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';

			}

		</script>

		<!-- LDraw.org CC BY 2.0 Parts Library attribution -->
		<div style="display: block; position: absolute; bottom: 8px; left: 8px; width: 160px; padding: 10px; background-color: #F3F7F8;">
			<center>
				<a href="http://www.ldraw.org"><img style="width: 145px" src="models/ldraw/LEGO/ldraw_org_logo/Stamp145.png"></a>
				<br />
				<a href="http://www.ldraw.org/">This software uses the LDraw Parts Library</a>
			</center>
		</div>
		<div style="position: absolute; bottom: 8px; left: 200px; padding: 4px; background-color: #F3F7F8;">
		<a href="http://tenteros.land/foro/viewtopic.php?f=47&t=154">TENTE Parts Library CC BY 4.0 by the community.</a>
		</div>
		<!--
		<div style="position: absolute; top: 8px; left: 20px; padding: 4px; background-color: #F3F7F8;">
		TEST Num: 1
		</div>
		-->

	</body>
</html>

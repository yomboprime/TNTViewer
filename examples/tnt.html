<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TNT Viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>

	<body>

		<script src="js/libs/ammo.wasm.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/lil-gui.module.min.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';

			import { LDrawLoader } from './jsm/loaders/LDrawLoader.js';
			//import { LDrawUtils } from './jsm/utils/LDrawUtils.js';

			const constructionSets = [
				'LEGO',
				'TENTE',
				'EXINCASTILLOS'
			];
			const constructionSetScale = {
				'LEGO': 1,
				'TENTE': 0.4,
				'EXINCASTILLOS': 1
			};
			let currentConstructionSet;

			let container, progressBarDiv;

			let camera, scene, renderer, controls, gui, guiData;

			let lDrawLoader;

			let parts;
			let models;
			let modelDiameter, turn;
			let modelBbox;
			const meanPos = new THREE.Vector3();
			const ANIM_STOPPED = 0;
			const ANIM_FALLING = 1;
			const ANIM_CONSTRUCTING = 2;
			const ANIM_PAUSED = 3;
			let animationState;
			let animationCreated;
			let timeNextState;
			let stepDuration = 1.5;
			let constructionDuration;
			let time = 0;
			let timeFactor = 1;
			let pausedTimeFactor = 1;
			let pauseOnNextStep;
			let pauseOnNextStepStep;

			const clock = new THREE.Clock();
			let curve;

			let timeFactorController;
			let constructionStepController;
			let animationButtonController;
			let modelTitleController;
			let pathController;
			let modelSeriesController;
			let modelRefController;
			let modelInfoURLController;

			let infoDiv;

			// Physics variables
			let collisionConfiguration;
			let dispatcher;
			let broadphase;
			let solver;
			let physicsWorld;
			let dynamicObjects = [];
			let btVectorAux1;
			let btQuatAux1;
			let btTransformAux1;

			const vector3Temp1 = new THREE.Vector3();
			const vector3Temp2 = new THREE.Vector3();
			const vector3Temp3 = new THREE.Vector3();
			const quatTemp1 = new THREE.Quaternion();
			const matrix4Temp1 = new THREE.Matrix4();
			const eulerTemp1 = new THREE.Euler();

			const ldrawPath = 'models/ldraw/';
			let dataBase;

			/*= {
				'Car': 'car.ldr_Packed.mpd',
				'Lunar Vehicle': '1621-1-LunarMPVVehicle.mpd_Packed.mpd',
				'Radar Truck': '889-1-RadarTruck.mpd_Packed.mpd',
				'Trailer': '4838-1-MiniVehicles.mpd_Packed.mpd',
				'Bulldozer': '4915-1-MiniConstruction.mpd_Packed.mpd',
				'Helicopter': '4918-1-MiniFlyers.mpd_Packed.mpd',
				'Plane': '5935-1-IslandHopper.mpd_Packed.mpd',
				'Lighthouse': '30023-1-Lighthouse.ldr_Packed.mpd',
				'X-Wing mini': '30051-1-X-wingFighter-Mini.mpd_Packed.mpd',
				'AT-ST mini': '30054-1-AT-ST-Mini.mpd_Packed.mpd',
				'AT-AT mini': '4489-1-AT-AT-Mini.mpd_Packed.mpd',
				'Shuttle': '4494-1-Imperial Shuttle-Mini.mpd_Packed.mpd',
				'TIE Interceptor': '6965-1-TIEIntercep_4h4MXk5.mpd_Packed.mpd',
				'Star fighter': '6966-1-JediStarfighter-Mini.mpd_Packed.mpd',
				//'X-Wing': '7140-1-X-wingFighter.mpd_Packed.mpd',
				'AT-ST': '10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'
			};*/

			Ammo().then( function ( AmmoLib ) {

				Ammo = AmmoLib;

				init();

			} );

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 150, 200, 250 );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				// scene

				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xdeebed );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment() ).texture;

				//scene.add( new THREE.AxesHelper( 100 ) );

				controls = new OrbitControls( camera, renderer.domElement );

				const curvePositions = [
					new THREE.Vector3( 0, 0, 0 ),
					new THREE.Vector3( 0.25, 0.38, 0 ),
					new THREE.Vector3( 0.75, 0.62, 0 ),
					new THREE.Vector3( 1, 1, 0 ),
				];
				curve = new THREE.CatmullRomCurve3( curvePositions );

				//

				currentConstructionSet = 'TENTE';

				lDrawLoader = new LDrawLoader();
				lDrawLoader.smoothNormals = true;
				lDrawLoader.setPath( getLibraryPath( currentConstructionSet ) );
				lDrawLoader.preloadMaterials( 'LDCONFIG.LDR' ).then( () => {

					getModelsDataBase( currentConstructionSet, ( db ) => {

						dataBase = db;

						// Load config
						//localStorage.clear();

						let initialModel = isOptionSet( 'modelPath' ) ? getOption( 'modelPath', false ) : 'oficiales/Aire_0501_servicio_autopista.ldr';
						const urlParams = new URLSearchParams( window.location.search );
						if ( urlParams.get( 'modelPath' ) ) initialModel = urlParams.get( 'modelPath' );
						if ( urlParams.get( 'modelId' ) ) {

							const mp = searchModelByField( 'id', urlParams.get( 'modelId' ) );
							if ( mp ) initialModel = dataBase.models[ mp ].path;

						}

						let displayLines = isOptionSet( 'displayLines' ) ? getOption( 'displayLines' ) : true;

						const backgroundColor = { r: scene.background.r, g: scene.background.g, b: scene.background.b }
						if ( isOptionSet( 'backgroundColor.r' ) ) {

							backgroundColor.r = getOption( 'backgroundColor.r' );
							backgroundColor.g = getOption( 'backgroundColor.g' );
							backgroundColor.b = getOption( 'backgroundColor.b' );
							scene.background.setRGB( backgroundColor.r, backgroundColor.g, backgroundColor.b );

						}

						const mainMat = lDrawLoader.getMainMaterial();
						const mainEdgeMat = mainMat.userData.edgeMaterial;
						const mainEdgeCondMat = mainEdgeMat.userData.conditionalEdgeMaterial;

						if ( isOptionSet( 'mainColor.r' ) ) {

							const r = getOption( 'mainColor.r' );
							const g = getOption( 'mainColor.g' );
							const b = getOption( 'mainColor.b' );
							mainMat.color.setRGB( r, g, b );

						}

						if ( isOptionSet( 'mainEdgeColor.r' ) ) {

							const r = getOption( 'mainEdgeColor.r' );
							const g = getOption( 'mainEdgeColor.g' );
							const b = getOption( 'mainEdgeColor.b' );
							mainEdgeMat.color.setRGB( r, g, b );
							mainEdgeCondMat.color.setRGB( r, g, b );

						}

						const mainColor = { r: mainMat.color.r, g: mainMat.color.g, b: mainMat.color.b }
						const mainEdgeColor = { r: mainEdgeMat.color.r, g: mainEdgeMat.color.g, b: mainEdgeMat.color.b }

						guiData = {
							modelFileName: initialModel,
							animationButton: animationButton,
							displayLines: displayLines,
							backgroundColor: backgroundColor,
							mainColor: mainColor,
							mainEdgeColor: mainEdgeColor,
							constructionStep: 0,
							timeFactor: 1,
							goToNextStep: goToNextStep,
							goToPrevStep: goToPrevStep,
							modelTitle: '',
							modelSeries: '',
							modelRef: '',
							modelInfoURL: '',
							path: '',
							modelBboxInfo: ''
						};

						window.addEventListener( 'resize', onWindowResize );

						progressBarDiv = document.createElement( 'div' );
						progressBarDiv.innerText = 'Loading...';
						progressBarDiv.style.fontSize = '3em';
						progressBarDiv.style.color = '#888';
						progressBarDiv.style.display = 'block';
						progressBarDiv.style.position = 'absolute';
						progressBarDiv.style.top = '50%';
						progressBarDiv.style.width = '100%';
						progressBarDiv.style.textAlign = 'center';

						initPhysics();

						reloadObject( true );

						animate();

					} );

				} );

			}

			function initPhysics() {

				// Physics configuration

				collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
				dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
				broadphase = new Ammo.btDbvtBroadphase();
				solver = new Ammo.btSequentialImpulseConstraintSolver();
				physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration );
				physicsWorld.setGravity( new Ammo.btVector3( 0, - 150, 0 ) );

				// Create the floor body

				const groundShape = new Ammo.btStaticPlaneShape( new Ammo.btVector3( 0, 1, 0 ), 0 );
				const groundTransform = new Ammo.btTransform();
				groundTransform.setIdentity();
				const groundMass = 0;
				const groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
				const groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
				const groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
				physicsWorld.addRigidBody( groundBody );

				btVectorAux1 = new Ammo.btVector3( 0, 0, 0 );
				btQuatAux1 = new Ammo.btQuaternion( 0, 0, 0, 1 );
				btTransformAux1 = new Ammo.btTransform();

			}

			function updatePhysics( deltaTime ) {

				physicsWorld.stepSimulation( deltaTime, 5 );

				// Update objects
				for ( let i in dynamicObjects ) {

					const object = dynamicObjects[ i ];
					const objPhys = object.userData.physicsBody;
					const ms = objPhys.getMotionState();
					if ( ms ) {

						ms.getWorldTransform( btTransformAux1 );
						const p = btTransformAux1.getOrigin();
						const q = btTransformAux1.getRotation();
						object.position.set( p.x(), p.y(), p.z() );
						object.quaternion.set( q.x(), q.y(), q.z(), q.w() );

					}

				}

			}

			function createRigidBody( object, physicsShape, mass = 0 ) {

				const pos = object.position;
				const quat = object.quaternion;

				const transform = btTransformAux1;
				transform.setIdentity();
				btVectorAux1.setValue( pos.x, pos.y, pos.z );
				transform.setOrigin( btVectorAux1 );
				btQuatAux1.setValue( quat.x, quat.y, quat.z, quat.w )
				transform.setRotation( btQuatAux1 );

				const motionState = new Ammo.btDefaultMotionState( transform );

				const localInertia = new Ammo.btVector3( 0, 0, 0 );
				physicsShape.calculateLocalInertia( mass, localInertia );

				const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
				const body = new Ammo.btRigidBody( rbInfo );

				body.setFriction( 0.5 );

				object.userData.physicsBody = body;

				if ( mass > 0 ) {

					dynamicObjects.push( object );

					// Disable deactivation
					body.setActivationState( 4 );

				}

				physicsWorld.addRigidBody( body );

			}

			function updateRigidBodyFromObject( object ) {

				const pos = object.position;
				const quat = object.quaternion;

				const transform = btTransformAux1;
				transform.setIdentity();
				btVectorAux1.setValue( pos.x, pos.y, pos.z );
				transform.setOrigin( btVectorAux1 );
				btQuatAux1.setValue( quat.x, quat.y, quat.z, quat.w )
				transform.setRotation( btQuatAux1 );

				const motionState = new Ammo.btDefaultMotionState( transform );

				object.userData.physicsBody.setMotionState( motionState );

			}

			function getTurnOffset() {

				//return 0;
				return 2.1 * ( turn ? modelDiameter : - modelDiameter );

			}

			function placePartRandomly( part, diameter ) {

				// TODO old.

				part.position.set(
					( Math.random() - 0.5 ) * diameter + getTurnOffset(),
					( Math.random() + 0.6 ) * diameter,
					( Math.random() - 0.5 ) * diameter
				);
				part.quaternion.setFromEuler(
					eulerTemp1.set(
						( 2 * Math.PI * Math.random() ),
						( 2 * Math.PI * Math.random() ),
						( 2 * Math.PI * Math.random() )
					)
				);

			}

			function updateObjectsVisibility() {

				function updateObjects( objects ) {
					for ( let i in objects ) {

						objects[ i ].traverse( c => {

							if ( c.isLineSegments ) {

								c.visible = guiData.displayLines;

							}

						} );

					}

				}

				updateObjects( models );
				updateObjects( parts );

			}

			function isPartType( type ) {

				return type === 'Part' || type === 'Unofficial_Part';

			}

			function reloadObject( resetCamera ) {

				if ( parts ) for ( let i in parts ) {

					scene.remove( parts[ i ] );
					physicsWorld.removeRigidBody( parts[ i ].userData.physicsBody );

				}
				parts = undefined;
				if ( models ) for ( let i in models ) scene.remove( models[ i ] );
				models = undefined;

				updateProgressBar( 0 );
				showProgressBar();

				const isLoadingPart = isPartPath( guiData.modelFileName );

				lDrawLoader.setPartsLibraryPath( getLibraryPath( currentConstructionSet ) );
				lDrawLoader.setPath( getModelPath( currentConstructionSet ) );
				lDrawLoader.load( guiData.modelFileName, function ( model ) {

					if ( parts ) {

						for ( let i in parts ) {

							const part = parts[ i ];

							scene.remove( part );

							physicsWorld.removeRigidBody( part.userData.physicsBody );

						}

					}
					if ( models ) for ( let i in models ) scene.remove( models[ i ] );

					parts = [];
					models = [];
					dynamicObjects = [];
					turn = true;

					// Convert from LDraw coordinates: rotate 180 degrees around OX
					model.rotation.x = Math.PI;

					modelBbox = new THREE.Box3().setFromObject( model );
					const size = modelBbox.getSize( new THREE.Vector3() );
					const radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.5;
					modelDiameter = 2 * radius;

					// Put above floor
					model.position.y = - modelBbox.min.y;

					// Extrude a little bit the stickers
					const stickers = [];
					model.traverse( c => {

						if ( c.userData.fileName ) {

							const part = dataBase.parts[ c.userData.fileName ];
							if ( part && part.title.indexOf( 'Etiqueta' ) >= 0 ) stickers.push( c );
						}

					} );
					for ( let s in stickers ) {

						stickers[ s ].traverse( c => {

							if ( c.isMesh ) {

								const vertices = c.geometry.getAttribute( 'position' ).array;
								const normals = c.geometry.getAttribute( 'normal' ).array;

								for ( let ip = 0, np = vertices.length; ip < np; ip += 3 ) {

									vector3Temp1.fromArray( vertices, ip );
									vector3Temp2.fromArray( normals, ip );
									vector3Temp3.copy( vector3Temp2 ).setLength( 0.5 );
									vector3Temp1.add( vector3Temp3 );
									vector3Temp1.toArray( vertices, ip );

								}

							}

						} );

					}

					models.push( model );
					scene.add( model );

					updateObjectsVisibility();

					time = 0;
					animationState = ANIM_STOPPED;
					animationCreated = false;

					// Adjust camera

					if ( resetCamera ) {

						const pos = modelBbox.getCenter( new THREE.Vector3() );
						pos.y += model.position.y;
						setCamera( pos.x, pos.y, pos.z );

					}

					createGUI();

					guiData.modelTitle = "No title.";
					guiData.path = guiData.modelFileName;
					guiData.modelSeries = "No series.";
					guiData.modelRef = "No ref.";
					guiData.modelInfoURL = "No URL.";
					let modelInfo = dataBase.models[ guiData.modelFileName ];

					if ( ! modelInfo ) {

						modelInfo = dataBase.parts[ guiData.modelFileName.substring( '../parts/'.length ) ];

					}

					if ( modelInfo ) {

						if ( modelInfo.path ) guiData.path = modelInfo.path;
						if ( modelInfo.title ) guiData.modelTitle = modelInfo.title;
						if ( modelInfo.seriesNumber ) guiData.modelSeries = modelInfo.seriesNumber;
						if ( modelInfo.refNumber ) guiData.modelRef = modelInfo.refNumber;
						else if ( modelInfo.metaData ) guiData.modelRef = modelInfo.metaData;
						if ( modelInfo.id && Number.isInteger( parseInt( modelInfo.id ) ) ) guiData.modelInfoURL = 'https://tente.spread.name/id/' + modelInfo.id;

						pathController.updateDisplay();
						modelTitleController.updateDisplay();
						modelSeriesController.updateDisplay();
						modelRefController.updateDisplay();
						modelInfoURLController.updateDisplay();

						let infoText = '';
						let infoHeight = 50;

						if ( modelInfo.id && Number.isInteger( parseInt( modelInfo.id ) ) ) {

							infoText += 'Go <a href="https://tente.spread.name/id/' + modelInfo.id + '"><b>here for model info</b> (external link)</a>';

						}

						infoText += '<br>See <a href="https://yomboprime.github.io/TNTViewer/examples/tnt_models.html">models</a> and ' +
							'<a href="https://yomboprime.github.io/TNTViewer/examples/tnt_parts.html">parts</a> lists.' +
							'<br><a href="https://github.com/yomboprime/TNTViewer">TNTViewer code at Github</a>';

						infoDiv.innerHTML = infoText;
						infoDiv.style.bottom = infoHeight + 'px';

					}

					hideProgressBar();

				}, onProgress, onError );

			}

			function isPartPath( path ) {

				return path.startsWith( '../parts/' );

			}

			function searchModelByField( field, value ) {

				for ( modelPath in database.modelPathsList ) {

					const model = dataBase.models[ modelPath ];

					if ( model[ field ] === value ) return modelPath;

				}

				return null;

			}

			function setCamera( x, y, z ) {

				controls.target0.set( x, y, z );
				controls.position0.set( - 2.3, 1, 2 ).multiplyScalar( modelDiameter * 0.5 ).add( controls.target0 );
				controls.reset();

			}

			function animationButton() {

				switch ( animationState ) {

					case ANIM_STOPPED:
						startAnimation();
						break;

					case ANIM_CONSTRUCTING:
						if ( timeFactor === 0 ) resumeAnimation( pausedTimeFactor );
						else pauseAnimation();
						break;

					default:
						break;

				}

			}

			function startAnimation() {

				if ( animationState !== ANIM_STOPPED ) return;

				if ( ! animationCreated ) {

					createAnimation();

					time = 0;
					timeNextState = 5;
					animationState = ANIM_FALLING;

				}
				else {

					//reenablePhysics();
					beginConstruction();

				}

				timeFactor = Math.abs( timeFactor );
				pausedTimeFactor = timeFactor;
				guiData.timeFactor = timeFactor;
				timeFactorController.updateDisplay();
				pauseOnNextStep = false;
				pauseOnNextStepStep = - 1;

				animationButtonController.name( "Pause animation" );

			}

			function pauseAnimation() {

				if ( animationState !== ANIM_CONSTRUCTING || timeFactor === 0 ) return false;

				pausedTimeFactor = timeFactor;
				timeFactor = 0;

				animationButtonController.name( "Resume animation" );
				guiData.timeFactor = timeFactor;
				timeFactorController.updateDisplay();

				return true;

			}

			function resumeAnimation( timeFactorParam ) {

				if ( animationState === ANIM_CONSTRUCTING ) animationButtonController.name( "Pause animation" );

				timeFactor = timeFactorParam;

				guiData.timeFactor = timeFactor;
				timeFactorController.updateDisplay();

				return true;

			}

			function animationGoToStep( constructionStep ) {

				if ( animationState !== ANIM_CONSTRUCTING ) return;

				constructionStep = Math.max( 0, Math.min( parts.length, constructionStep ) );

				time = getTimeByStep( constructionStep + 1 );

				for ( let i in parts ) {

					positionPart( parts[ i ], time );

				}

			}

			function getStepByTime( t ) {

				return Math.max( 0, Math.min( parts.length - 1, Math.floor( t / stepDuration ) ) );

			}

			function getTimeByStep( s ) {

				return s * stepDuration;

			}

			function goToPrevStep() {

				if ( ! parts ) return;

				const remTime = time - Math.floor( time / stepDuration ) * stepDuration;
				const rem = remTime / stepDuration;
				let firstHalf = rem < 0.5 && remTime > 0;
				const newStep = Math.max( 0, Math.min( parts.length - 1, getStepByTime( time ) - 1 ) );

				time = getTimeByStep( newStep );
				for ( let i in parts ) {

					positionPart( parts[ i ], time );

				}

				animationState = ANIM_CONSTRUCTING;

			}

			function goToNextStep() {

				if ( ! parts ) return;

				const remTime = time - Math.floor( time / stepDuration ) * stepDuration;
				const rem = remTime / stepDuration;
				let firstHalf = rem < 0.5 && remTime > 0;
				const newStep = Math.max( 0, Math.min( parts.length, Math.floor( time / stepDuration ) + 1 ) );

				time = getTimeByStep( newStep );
				for ( let i in parts ) {

					positionPart( parts[ i ], time );

				}

				animationState = ANIM_CONSTRUCTING;

			}

			function createAnimation() {

				animationCreated = true;

				if ( ! models || models.length === 0 ) return;

				const model = models[ 0 ];
				models.splice( 0, 1 );
				scene.remove( model );

				parts = model.children.slice();
/*
				model.traverse( c => {

					console.log( "fileName: " + c.userData.fileName );


					//if ( isPartType( c.userData.type ) ) {

					//	parts.push( c );

					//}

				} );
*/
				model.updateMatrixWorld( true );

				meanPos.set( 0, 0, 0 );

				for ( let i in parts ) {

					const partOrig = parts[ i ];
					const part = partOrig.clone();
					parts[ i ] = part;
					part.userData.type = partOrig.userData.type;
					part.userData.numConstructionSteps = partOrig.userData.numConstructionSteps;
					part.userData.constructionStep = partOrig.userData.constructionStep;

					matrix4Temp1.copy( part.matrixWorld );
					part.removeFromParent();

					part.position.set( 0, 0, 0 );
					part.quaternion.set( 0, 0, 0, 1 );
					part.updateMatrixWorld( true );
					const bbox = new THREE.Box3().setFromObject( part );
					bbox.getSize( vector3Temp1 );
					const sx = vector3Temp1.x;
					const sy = vector3Temp1.y;
					const sz = vector3Temp1.z;
					const objectSize = sx > sy ? ( sz > sx ? sz : sx ) : ( sz > sy ? sz : sy );
					part.userData.objectSize = objectSize;
					part.userData.sx = sx;
					part.userData.sy = sy;
					part.userData.sz = sz;
					part.userData.bbox = bbox;

					matrix4Temp1.decompose( part.position, part.quaternion, part.scale );
					part.userData.partPosition = new THREE.Vector3().copy( part.position );
					part.userData.partQuaternion = new THREE.Quaternion().copy( part.quaternion );
					part.userData.positionStart = new THREE.Vector3();
					part.userData.positionEnd = new THREE.Vector3();
					part.userData.quaternionStart = new THREE.Quaternion();

					meanPos.add( part.userData.partPosition );

					//placePartRandomly( part, objectSize * 5 );

				}

				const fileNumConstructionSteps = model.userData.numConstructionSteps;

				if ( parts.length > 0 ) {

					meanPos.multiplyScalar( 1 / parts.length );

				}

				meanPos.x += getTurnOffset();

				for ( let p in parts ) {

					const part = parts[ p ];

					part.position.add( meanPos );
					part.position.y += meanPos.y * 2;

					const physicsShape = new Ammo.btBoxShape(
						new Ammo.btVector3(
							part.userData.sx * 0.5,
							part.userData.sy * 0.5,
							part.userData.sz * 0.5
						)
					);

					physicsShape.setMargin( part.userData.objectSize * 0.01 );
					const mass = Math.pow( 10 * part.userData.objectSize, 2.2 );
					createRigidBody( part, physicsShape, mass );
					part.userData.physicsControlled = true;

					scene.add( part );

				}

				// Sort parts

				if ( fileNumConstructionSteps === 1 ) {

					sortParts( parts );

				}

				const stepsParts = [];
				for ( let p in parts ) {

					const part = parts[ p ];

					let constructionStep = p;
					if ( fileNumConstructionSteps > 1 ) constructionStep = part.userData.constructionStep;
					part.userData.constructionStep = constructionStep;

					if ( ! stepsParts[ constructionStep ] ) stepsParts[ constructionStep ] = [];
					stepsParts[ constructionStep ].push( part );

				}

				if ( fileNumConstructionSteps > 1 ) {

					let cs = 0;
					for ( let sp in stepsParts ) {

						const stepParts = stepsParts[ sp ];

						sortParts( stepParts );

						for ( let p in stepParts ) {

							const part = stepParts[ p ];
							part.userData.constructionStep = cs ++;

						}

					}

					parts.sort( ( a, b ) => {

						const sa = a.constructionStep;
						const sb = b.constructionStep;

						return sa === sb ? 0 : ( sa < sb ? - 1 : 1 );

					} );

				}

				constructionDuration = stepDuration * parts.length;
				constructionStepController.min( 1).max( parts.length );

			}

			function sortParts( partsArray ) {

				partsArray.sort( ( a, b ) => {

					const ay = - a.userData.bbox.max.y + a.position.y;
					const by = - b.userData.bbox.max.y + b.position.y;

					return ay === by ? 0 : ( ay < by ? - 1 : 1 );


				} );
			}

			function handleAnimation( deltaTime ) {

				if ( ! parts ) return;

				switch ( animationState ) {

					case ANIM_FALLING:
						if ( time >= timeNextState ) {

							beginConstruction();
							animParts( deltaTime );

						}
						break;

					case ANIM_CONSTRUCTING:
						animParts( deltaTime );
						break;

						break;

					default:
						break;

				}

			}

			function beginConstruction() {

				time = 0;
				animationState = ANIM_CONSTRUCTING;

				for ( let i in parts ) {

					positionPart( parts[ i ], time );

				}

				constructionStepController.enable();

			}

			function animParts( deltaTime ) {

				let timeNextStep = time + deltaTime;

				if ( ( deltaTime > 0 && time >= constructionDuration ) || ( deltaTime < 0 && time <= 0 ) ) {

					animationState = ANIM_STOPPED;
					time = deltaTime > 0 ? constructionDuration : 0;
					timeNextStep = time;
					animationButtonController.name( "Start animation" );
					constructionStepController.disable();

					//animationState = ANIM_WAIT;
					//timeNextState = time + 3;
					//turn = ! turn;

				}

				let currentConstructionStep = getStepByTime( time );
				let nextConstructionStep = getStepByTime( timeNextStep );
				let displayConstructionStep = currentConstructionStep;

				if ( Math.sign( nextConstructionStep - currentConstructionStep ) >= 0 ) {

					currentConstructionStep = Math.max( 0, currentConstructionStep - 1 );
					nextConstructionStep = Math.min( parts.length - 1, nextConstructionStep + 1 );

				}
				else {

					nextConstructionStep = Math.max( 0, nextConstructionStep - 1 );
					currentConstructionStep = Math.min( parts.length - 1, currentConstructionStep + 1 );

				}

				const numSteps = Math.abs( currentConstructionStep - nextConstructionStep ) + 1;
				const stepsDir = Math.sign( nextConstructionStep - currentConstructionStep );
				const step0 = Math.min( currentConstructionStep, nextConstructionStep );

				let step = step0;
				for ( let i = 0; i < numSteps; i ++ ) {

					if ( step >= 0 && step <= parts.length - 1 ) {

						positionPart( parts[ step ], time );

					}

					step += stepsDir;

				}

				guiData.constructionStep = displayConstructionStep + 1;
				constructionStepController.updateDisplay();

			}


			function positionPart( part, t ) {

				if ( part.userData.physicsControlled ) {

					part.userData.positionStart.copy( part.position );
					part.userData.quaternionStart.copy( part.quaternion );
					part.userData.positionEnd.copy( part.userData.partPosition );

					physicsWorld.removeRigidBody( part.userData.physicsBody );
					dynamicObjects.splice( dynamicObjects.indexOf( part ), 1 );

					part.userData.physicsControlled = false;

				}

				const step = getStepByTime( t );

				let tClamped;

				if ( step > part.userData.constructionStep ) tClamped = 1;
				else if ( step < part.userData.constructionStep ) tClamped = 0;
				else tClamped = Math.min( 1, Math.max( 0, ( t - getTimeByStep( step ) ) / stepDuration ) );

				curve.getPoint( tClamped, vector3Temp1 );
				const tCurve = vector3Temp1.y;

				vector3Temp1.lerpVectors( part.userData.positionStart, part.userData.positionEnd, tCurve );
				vector3Temp2.subVectors( part.userData.positionEnd, part.userData.positionStart );
				const d = vector3Temp2.length();
				const y = d * ( - Math.pow( tCurve - 0.5, 2 ) + 0.25 );

				part.position.copy( vector3Temp1 );
				part.position.y += y;

				part.quaternion.slerpQuaternions( part.userData.quaternionStart, part.userData.partQuaternion, tCurve );

			}

			function reenablePhysics() {

				for ( let i in parts ) {

					const part = parts[ i ];

					updateRigidBodyFromObject( part );
					physicsWorld.addRigidBody( part.userData.physicsBody );
					dynamicObjects.push( part );
					part.userData.physicsControlled = true;

				}

			}

			function getModelsDataBase( constructionSet, onLoaded ) {

				const loader = new THREE.FileLoader();
				loader.load( getModelPath( constructionSet ) + 'models.json', ( content ) => {

					const dataBase = JSON.parse( content );

					onLoaded( dataBase );

				} );

			}

			function getLibraryPath( constructionSet ) {

				return ldrawPath + constructionSet  + '/';

			}

			function getModelPath( constructionSet ) {

				return ldrawPath + constructionSet  + '/models/';

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createGUI() {

				if ( gui ) {

					gui.destroy();

				}

				gui = new GUI( { width: 500 } );

				const fileNameMap = {};
				for ( let i in dataBase.modelPathsList ) {

					const filePath = dataBase.modelPathsList[ i ];
					const model = dataBase.models[ filePath ];

					fileNameMap[ model.path ] = filePath;

				}
				gui.add( guiData, 'modelFileName', fileNameMap ).name( 'Model' ).onFinishChange( () => {

					setOption( 'modelPath', guiData.modelFileName );
					reloadObject( true );

				} );

				const infoFolder = gui.addFolder( "Model info" );

				modelTitleController = infoFolder.add( guiData, 'modelTitle' ).name( 'Title' );
				modelSeriesController = infoFolder.add( guiData, 'modelSeries' ).name( 'Series' );
				modelRefController = infoFolder.add( guiData, 'modelRef' ).name( 'Reference' );
				modelInfoURLController = infoFolder.add( guiData, 'modelInfoURL' ).name( 'Info URL' );
				pathController = infoFolder.add( guiData, 'path' ).name( 'Path' );
				modelBbox.getSize( vector3Temp1 ).multiplyScalar( constructionSetScale[ currentConstructionSet ] );
				function round10( x ) { return Math.round( x * 10 ) / 10; }
				guiData.modelBboxInfo = round10( vector3Temp1.x ) + " x " + round10( vector3Temp1.z ) + " x " + round10( vector3Temp1.y );
				infoFolder.add( guiData, 'modelBboxInfo' ).name( 'Model bounds (mm)' );

				const optionsFolder = gui.addFolder( "Options" );

				optionsFolder.addColor( guiData, 'mainColor' ).name( 'Main color' ).onChange( () => {

					const mainMat = lDrawLoader.getMainMaterial();
					mainMat.color.setRGB( guiData.mainColor.r, guiData.mainColor.g, guiData.mainColor.b );
					setOption( 'mainColor.r', mainMat.color.r );
					setOption( 'mainColor.g', mainMat.color.g );
					setOption( 'mainColor.b', mainMat.color.b );

				} );

				optionsFolder.addColor( guiData, 'mainEdgeColor' ).name( 'Main edge color' ).onChange( () => {

					const mainMat = lDrawLoader.getMainMaterial();
					//const mainEdgeMat = lDrawLoader.getMainEdgeMaterial();
					const mainEdgeMat = mainMat.userData.edgeMaterial;
					const mainEdgeCondMat = mainEdgeMat.userData.conditionalEdgeMaterial;
					mainEdgeMat.color.setRGB( guiData.mainEdgeColor.r, guiData.mainEdgeColor.g, guiData.mainEdgeColor.b );
					mainEdgeCondMat.color.setRGB( guiData.mainEdgeColor.r, guiData.mainEdgeColor.g, guiData.mainEdgeColor.b );
					setOption( 'mainEdgeColor.r', mainEdgeMat.color.r );
					setOption( 'mainEdgeColor.g', mainEdgeMat.color.g );
					setOption( 'mainEdgeColor.b', mainEdgeMat.color.b );

				} );

				optionsFolder.addColor( guiData, 'backgroundColor' ).name( 'Background color' ).onChange( () => {

					scene.background.setRGB( guiData.backgroundColor.r, guiData.backgroundColor.g, guiData.backgroundColor.b );

				} ).onFinishChange( () => {

					setOption( 'backgroundColor.r', guiData.backgroundColor.r );
					setOption( 'backgroundColor.g', guiData.backgroundColor.g );
					setOption( 'backgroundColor.b', guiData.backgroundColor.b );

				} );

				optionsFolder.add( guiData, 'displayLines' ).name( 'Display Lines' ).onChange( () => {

					setOption( 'displayLines', guiData.displayLines );

					updateObjectsVisibility();

				} );

				optionsFolder.close();


				animationButtonController = gui.add( guiData, 'animationButton' ).name( 'Start animation' );

				constructionStepController = gui.add( guiData, 'constructionStep', 1, 1 ).step( 1 ).name( 'Construction step' ).onChange( () => {

					pauseAnimation();

					animationGoToStep( guiData.constructionStep - 1 );

				} );
				constructionStepController.disable();

				timeFactorController = gui.add( guiData, 'timeFactor', - 5, 5 ).name( 'Time factor' ).onChange( () => {

					resumeAnimation( guiData.timeFactor );

				} );

				gui.add( guiData, 'goToPrevStep' ).name( '⬅️ Go back one step' );
				gui.add( guiData, 'goToNextStep' ).name( '➡️ Go forward one step' );


				if ( container.contains( infoDiv ) ) container.removeChild( infoDiv );
				infoDiv = document.createElement( 'div' );
				infoDiv.innerHTML = 'If model does not load go to the <a href="https://yomboprime.github.io/TNTViewer/examples/tnt_models.html">Models list</a> and try loading a different one.';
				infoDiv.style.position = 'absolute';
				infoDiv.style.bottom = '50px';
				infoDiv.style.left = '200px';
				infoDiv.style.width = '60%';
				infoDiv.style.color = '#A0B0C0';
				container.appendChild( infoDiv );


			}

			function getOption( name, parse = true ) {

				const v = localStorage.getItem( name );

				if ( parse ) return JSON.parse( v );

				return v;

			}

			function isOptionSet( name ) {

				const v = localStorage.getItem( name );

				return v !== null;

			}

			function setOption( name, value ) {

				localStorage.setItem( name, value );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				const deltaTime = clock.getDelta() * timeFactor;

				handleAnimation( deltaTime );
				//handleAnimation( 1 / 60 );

				if ( animationState === ANIM_FALLING ) updatePhysics( Math.abs( deltaTime ) );

				renderer.render( scene, camera );

				time += deltaTime;

			}

			function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					updateProgressBar( xhr.loaded / xhr.total );

					console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );

				}

			}

			function onError( e ) {

				const message = 'Error loading model: ' + e;
				progressBarDiv.innerText = message;
				console.log( message );

			}

			function showProgressBar() {

				document.body.appendChild( progressBarDiv );

			}

			function hideProgressBar() {

				if ( document.body.contains( progressBarDiv ) ) document.body.removeChild( progressBarDiv );

			}

			function updateProgressBar( fraction ) {

				progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';

			}

		</script>

		<!-- LDraw.org CC BY 2.0 Parts Library attribution -->
		<div style="display: block; position: absolute; bottom: 8px; left: 8px; width: 160px; padding: 10px; background-color: #F3F7F8;">
			<center>
				<a href="http://www.ldraw.org"><img style="width: 145px" src="models/ldraw/LEGO/ldraw_org_logo/Stamp145.png"></a>
				<br />
				<a href="http://www.ldraw.org/">This software uses the LDraw Parts Library</a>
			</center>
		</div>
		<div style="position: absolute; bottom: 8px; left: 200px; padding: 4px; background-color: #F3F7F8;">
		<a href="http://tenteros.land/foro/viewtopic.php?f=47&t=154">TENTE Parts Library CC BY 4.0 by the community.</a>
		</div>
		<!--
		<div style="position: absolute; top: 8px; left: 20px; padding: 4px; background-color: #F3F7F8;">
		TEST Num: 1
		</div>
		-->

	</body>
</html>
